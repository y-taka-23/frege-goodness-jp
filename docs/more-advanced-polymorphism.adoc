== 多相性特論

link:advanced-parametric-polymorphism.adoc[ひとつ前の記事] では、最終的にランク 2 の型を用いて以下のような `fzip` を得ました。

[source, haskell]
----
fzip :: (∀a.[a] → [a]) → [b] → [c] → [(b,c)]
fzip f xs ys = zip (f xs) (f ys)
----

=== 高階型が一般的すぎる場合

残念なことに、先に得た答えは、ありうるユースケースすべてをカバーしているわけではありません。例えば、以下の式は未だに書きなおすことができないままです。

[source, haskell]
----
let inc = map (1+) in zip (inc xs) (inc ys)
----

次のように書こうとすると、

[source, haskell]
----
fzip (map (1+)) [8..13] [1,2,3]
----

以下のようなエラーが返ってきてしまいます。

[source]
----
inferred type is more constrained than expected type
    inferred:  Num a => [a] -> [a]
    expected:  [a] -> [a]
----

つまり、`map (1+)` は型シグネチャが要求しているよりも一般性が不足しているのです。これが動作するのは数値に対してだけですが、 *任意の* リストを引数とする関数を渡せると宣言してしまっています。

もちろん、両方のリストともに数値型の関数をマップする、というよくある場合の解決策をひねり出すことは可能です。

[source, haskell]
----
nzip :: (Num c,Num b) => (∀a.Num a => [a] -> [a]) -> [b] -> [c] -> [(b,c)]
----

この数値版の zip を使えば、

[source, haskell]
----
frege> nzip (map (1+)) [8..13] (iterate (*1.5) 1)
[(9, 2.0),(10, 2.5),(11, 3.25),(12, 4.375),(13, 6.0625),(14, 8.59375)]
----

のように書くことが可能です。

しかし、型クラス制約のせいで見た目が前ほどエレガントではなくなってしまいました。しかもそれ以上にまずいことがあります。この書き方では _型クラスに対する抽象化_ ができないため (明らかに型システム上の欠点です)、使いたい型クラスそれぞれについて新しい関数を書く必要があるのです。例えば、

[source, haskell]
----
zip (map succ [8..13]) (map succ ['a', 'b', 'c'])
----

を修正するためには、

[source, haskell]
----
ezip :: (Enum c,Enum b) => (∀a.Enum a => [a] -> [a]) -> [b] -> [c] -> [(b,c)]
----

のようにする必要があります。

`ezip` および `nzip` の型は、型クラス名を除いてほとんど同じなので問題ありませんね？ ところで、`nzip` と `ezip` については型についてだけ述べたことに気づいたでしょうか？ これは、定義そのものは (もちろん関数名は除いて) `fzip` と同じものだからです。

しかし、仮に型クラスを抽象化できたとしても、一般化した新しいバージョンの `zip` を書くにはやはり次のようにしなければならないでしょう。

[source,haskell]
----
zip (map show [8..13]) (map show ['a', 'b', 'c'])
zip (filter (<maxBound) xs) (filter (<maxBound) ys)
----

前者は `Show` の制約の元で常に`[String]` を返り値としますが、これではここまでに述べた関数に対しては一般性が不十分です。後者では制約はひとつではなく、`[Bounded]` と `[Ord]` のふたつの制約を必要としています。どんな手をとったとしても、恣意的な例にせよそうでないにせよ、うまく動かない例にぶつかることになります。

=== 慰めの報酬

つまりは高階型は役に立たないということでしょうか？ 全くそんなことはありません！ 高階型は極めて強力ではあるものの、他のあらゆるものと同じく、プログラミングに関わる問題を全て解決してしまう銀の弾丸ではありません。したがって限界について知っておいたほうが賢明です。

次のセクションでは、*高カインド型* を用いてもっと素晴らしいことを行う方法について学びます。残念なことに、高カインド型と高階型はしばしば混同して議論されることがあります。この記事は用語についてきちんと理解する助けになるでしょう。

=== 高カインド型

最初に、*高カインド型* という用語には、「一杯の」という言い回しを *高カインド飲料* と呼ぶのと同じで、若干の語弊があることを認めねばなりません。「一杯の」は飲み物ではないどころか、物質世界に存在する、あるいは少なくとも存在しうるものをまったく表してはいません！

本当のところはこうです。「一杯の」 という言い回しは、いわば次に来る飲み物を待つ形で、「一杯の紅茶」「一杯のコーヒー」あるいは「一杯のミルク」のような概念を形成します。そして後者の概念は単に実在する (あるいは少なくとも想像できるような) 物体を表します。

同様に、`Maybe` や `[]`、`Either` は型ではなく、型レベルの関数です。これらは _型コンストラクタ_ とも呼ばれますが、この呼び方が充分に的を射ているとはいえない場合もままあります。例えば `Int`、`Maybe` および `Either` は 3 つとも型コンストラクタと呼ばれますが、これらの間には明らかな違いがあります。`Int` は型 (つまり `Int` 型を持つ値が存在する) ですが、`Maybe` は型ではなく、`Either` も型ではありません。

結局のところ、*高カインド型* という概念が表しているのは、型言語による特定の式が使用できる機能であり、この型言語は型そのものではなく型関数を記述します。

そのためには、型式の *カインド* を区別する記法があると便利です
(無用の混乱を避けるため「型式の型」ではなく「型式のカインド」という表現を使うことがあります)。

=== カインドの記法

型カインドの記法は極めてシンプルです。しかしだからといってカインドが単純である、あるいは少なくとも簡単に読み解けるというわけではありません。ルールはこうです。

1. 通常の型はカインド `\*` を持つ。例としては `Int` や `[Int]` あるいは `Int -> Int` など。カインド `*` を持つ型にはそれに属する値が存在し、例えば `42` や `[1,2,3]` あるいは `\n -> n+1` が該当する。
2. `k` がカインドであるとき、`(k)` も同じカインドである。
3. `k1` と `k2` がカインドであるとき、`k1 → k2` もカインドである。
4. 型の構文と同様に `->` は右結合である。曖昧さをなくすために `(* → \*) → *` あるいは `* → (* → *)` のように括弧を使用する。後者のみ `\* -> \*` と書いてもよい。
