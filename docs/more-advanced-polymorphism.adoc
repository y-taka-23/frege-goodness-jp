== 多相性特論

link:advanced-parametric-polymorphism.adoc[ひとつ前の記事] では、最終的にランク 2 の型を用いて以下のような `fzip` を得ました。

[source, haskell]
----
fzip :: (∀a.[a] → [a]) → [b] → [c] → [(b,c)]
fzip f xs ys = zip (f xs) (f ys)
----

=== 高階型が一般的すぎる場合

残念なことに、先に得た答えは、ありうるユースケースすべてをカバーしているわけではありません。例えば、以下の式は未だに書きなおすことができないままです。

[source, haskell]
----
let inc = map (1+) in zip (inc xs) (inc ys)
----

次のように書こうとすると、

[source, haskell]
----
fzip (map (1+)) [8..13] [1,2,3]
----

以下のようなエラーが返ってきてしまいます。

[source]
----
inferred type is more constrained than expected type
    inferred:  Num a => [a] -> [a]
    expected:  [a] -> [a]
----

つまり、`map (1+)` は型シグネチャが要求しているよりも一般性が不足しているのです。これが動作するのは数値に対してだけですが、 *任意の* リストを引数とする関数を渡せると宣言してしまっています。

もちろん、

[source, haskell]
----
nzip :: (Num c,Num b) => (∀a.Num a => [a] -> [a]) -> [b] -> [c] -> [(b,c)]
----

この数値版の zip を使えば、

[source, haskell]
----
frege> nzip (map (1+)) [8..13] (iterate (*1.5) 1)
[(9, 2.0),(10, 2.5),(11, 3.25),(12, 4.375),(13, 6.0625),(14, 8.59375)]
----

のように書くことが可能です。

しかし、型クラス制約のせいで見た目が前ほどエレガントではなくなってしまいました。
