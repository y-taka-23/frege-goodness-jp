== 多相性特論

link:advanced-parametric-polymorphism.adoc[ひとつ前の記事] では、最終的にランク 2 の型を用いて以下のような `fzip` を得ました。

[source, haskell]
----
fzip :: (∀a.[a] → [a]) → [b] → [c] → [(b,c)]
fzip f xs ys = zip (f xs) (f ys)
----

=== 高階型が一般的すぎる場合

残念なことに、先に得た答えは、ありうるユースケースすべてをカバーしているわけではありません。例えば、以下の式は未だに書きなおすことができないままです。

[source, haskell]
----
let inc = map (1+) in zip (inc xs) (inc ys)
----

次のように書こうとすると、

[source, haskell]
----
fzip (map (1+)) [8..13] [1,2,3]
----

以下のようなエラーが返ってきてしまいます。

[source]
----
inferred type is more constrained than expected type
    inferred:  Num a => [a] -> [a]
    expected:  [a] -> [a]
----

つまり、`map (1+)` は型シグネチャが要求しているよりも一般性が不足しているのです。これが動作するのは数値に対してだけですが、 *任意の* リストを引数とする関数を渡せると宣言してしまっています。

もちろん、両方のリストともに数値型の関数をマップする、というよくある場合の解決策をひねり出すことは可能です。

[source, haskell]
----
nzip :: (Num c,Num b) => (∀a.Num a => [a] -> [a]) -> [b] -> [c] -> [(b,c)]
----

この数値版の zip を使えば、

[source, haskell]
----
frege> nzip (map (1+)) [8..13] (iterate (*1.5) 1)
[(9, 2.0),(10, 2.5),(11, 3.25),(12, 4.375),(13, 6.0625),(14, 8.59375)]
----

のように書くことが可能です。

しかし、型クラス制約のせいで見た目が前ほどエレガントではなくなってしまいました。しかもそれ以上にまずいことがあります。この書き方では _型クラスに対する抽象化_ ができないため (明らかに型システム上の欠点です)、使いたい型クラスそれぞれについて新しい関数を書く必要があるのです。例えば、

[source, haskell]
----
zip (map succ [8..13]) (map succ ['a', 'b', 'c'])
----

を修正するためには、

[source, haskell]
----
ezip :: (Enum c,Enum b) => (∀a.Enum a => [a] -> [a]) -> [b] -> [c] -> [(b,c)]
----

のようにする必要があります。
