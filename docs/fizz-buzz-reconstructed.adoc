== 改めて FizaBuzz 問題

[quote]
____
充分に近くで観察したとき、あらゆる問題は奇妙かつ理解不能なものに見える。
____

ここまでで見たように、FizzBuzz 問題は、普通に想像するよりもずっとプログラミングの課題として興味深いものです。外側からは単純すぎる問題に見えますが、解の可能性は豊富に広がっています。

すでに述べた解 (link:fizz-buzz.adoc[最初の解答] および link:fizz-buzz-revised.adoc[修正版]) にはよい点も多数ありましたが、ここまで暗黙の内に無視してきた共通の欠点が存在します。巨大な数、例えば 1,000,000 以上に対して FizzBuzz の値を求める際には効率的に動作しないのです。元の解では答えを得るまでに 1,000,000 個の数をたどる必要があります。

この問題を解決するため、以下ではより _関数型の考え方_ の特徴を捉えた方法で FizzBuzz 問題の再構築を行います。

* 関数型プログラミングの根底にある問い
* 型によるモデリング
* 合成可能性
* 型に従って考える

一段上の関数型プログラミングの威力を手に入れましょう。

=== 関数型プログラミングの根底にある問い

関数型の考え方でプログラミング課題を解くときには、次の根本的な問いを考える必要があります。

.関数型プログラミングの根底にある問い
==========================
この機能は _何_ から _何_ への関数なのか？
==========================

FizzBuzz は整数の列から文字列の列への関数です。

.写像としての FizzBuzz
[source, haskell]
----
fizzbuzz :: [Int] -> [String]
fizzbuzz = map transform [1..100]
----

さて、ここでまた同じ疑問が生じます。`transform` は何から何への関数なのか？

もともとのゲームのルールに鑑みれば、この関数は整数 1 を文字列の "1" に、3 を "fizz" に、5 を "buzz" に、そして 15 を "fizzbuzz" に、といった変換を行います。

.変換の型
[source, haskell]
----
transform :: Int -> String
----

これで、`transform` を実装する上で考えなければならない問題は、残り 2 つです。

* ゲームのルール
* `toString` のロジック
