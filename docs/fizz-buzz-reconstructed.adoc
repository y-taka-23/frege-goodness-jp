== 改めて FizaBuzz 問題

[quote]
____
充分に近くで観察したとき、あらゆる問題は奇妙かつ理解不能なものに見える。
____

ここまでで見たように、FizzBuzz 問題は、普通に想像するよりもずっとプログラミングの課題として興味深いものです。外側からは単純すぎる問題に見えますが、解の可能性は豊富に広がっています。

すでに述べた解 (link:fizz-buzz.adoc[最初の解答] および link:fizz-buzz-revised.adoc[修正版]) にはよい点も多数ありましたが、ここまで暗黙の内に無視してきた共通の欠点が存在します。巨大な数、例えば 1,000,000 以上に対して FizzBuzz の値を求める際には効率的に動作しないのです。元の解では答えを得るまでに 1,000,000 個の数をたどる必要があります。

この問題を解決するため、以下ではより _関数型の考え方_ の特徴を捉えた方法で FizzBuzz 問題の再構築を行います。

* 関数型プログラミングの根底にある問い
* 型によるモデリング
* 合成可能性
* 型に従って考える

一段上の関数型プログラミングの威力を手に入れましょう。

=== 関数型プログラミングの根底にある問い

関数型の考え方でプログラミング課題を解くときには、次の根本的な問いを考える必要があります。

.関数型プログラミングの根底にある問い
==========================
この機能は _何_ から _何_ への関数なのか？
==========================

FizzBuzz は整数の列から文字列の列への関数です。

.写像としての FizzBuzz
[source, haskell]
----
fizzbuzz :: [Int] -> [String]
fizzbuzz = map transform [1..100]
----

さて、ここでまた同じ疑問が生じます。`transform` は何から何への関数なのか？

もともとのゲームのルールに鑑みれば、この関数は整数 1 を文字列の "1" に、3 を "fizz" に、5 を "buzz" に、そして 15 を "fizzbuzz" に、といった変換を行います。

.変換の型
[source, haskell]
----
transform :: Int -> String
----

これで、`transform` を実装する上で考えなければならない問題は、残り 2 つです。

* ゲームのルール
* `toString` のロジック

=== 型によるモデリング

ゲームのルールについて考えるところから始めましょう。

ここで我々が考えなければならないルールは以下の 3 つです。

* n が 3 で割り切れるならば、結果として "fizz" を加える
* n が 5 で割り切れるならば、結果として "buzz" を加える
* 他のルールが適用できなければ、結果として単に `show n` とする

言い換えれば、ルールは関数です。ではここで例の質問をもう一度繰り返しましょう。_何から何への関数_でしょうか？

まず操作するための数が必要です。これを `n` と呼びましょう。またすでに適用したルールの結果 (文字列のリストになる) も必要です。そして返すのは新しいルールのリストです。

.ルールを表す関数の型
[source, haskell]
----
type Rule = Int -> [String] -> [String]
----

fizz ルールをモデリングする第一歩として、以下のような方法が思いつくかもしれません。

.最初に思いつく fizz ルール
[source, haskell]
----
fizzRule n old = if n `rem` 3 > 0
                 then old
                 else old ++ ["fizz"]
----

確かにその通りなのですが、しかし同じことを "buzz" に対しても繰り返す必要があります。そこで割る数 (3 か 5) と結果となる単語 ("fizz" か "buzz") をパラメータにすることで、あらかじめ重複を除いておきます。

.パラメータ化された FizzBuzz ルール
----
divBy:: Int -> String -> Rule
divBy divisor word n old = if n `rem` divisor > 0
                           then old
                           else old ++ [word]

fizzRule:: Rule
fizzRule = divBy 3 "fizz"

buzzRule :: Rule
buzzRule = divBy 5 "buzz"
----

.消えたパラメータ？
****
上のコードでは、引数のパラメータである `n` と `old` が `fizzRole` と `buzzRule` では消えてしまっているかのように見えます。ここではむしろコードをいい感じにするためにあえて省略 (link::silent-notation.adoc[ポイントフリー]) しました。
****

さて、我々のアプローチに対する最初のリトマス試験紙として、次の問題を考えます。他のルールが適用できないときに、数字を返す `numberRule` をつくりだすことができるでしょうか？

これは難しくありません。必要なのは型に従って考えることだけです。

ルールは数と今までの結果のリストから新しい結果のリストを与える関数だったので、このような関数を考えることができます。

.場合分けによる「数字用」のルール
[source, haskell]
----
numberRule :: Rule
numberRule n []     = [show n]
numberRule _ result = result
----

=== 合成を可能にする

上で挙げたルールは独立にはうまく動きますが、しかし FizzBuzz ではルールを組み合わせる必要があります。ここが関数型のアプローチが輝く部分です。ルールは関数であり、そして関数の合成 (link:silent-notation.adoc[関数合成の記法]) は極めてシンプルです。
